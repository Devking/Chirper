Current Assignment:

Oh, no!!!! The server went down. Our client base is furious. We need to reimplement our back end to be more resilient, using replication.

Documentation:

Provide clear documentation describing:

how the data is kept in synch across your replicas.
how failure of one server is handled by the system.

--------------------

https://jaksa.wordpress.com/2009/05/01/active-and-passive-replication-in-distributed-systems/

Python Web Server is the "front end"
C++ Data Server is the "Replica Manager"

Active Replication:
    - have many data servers all running at the same time
    - each data server must keep track of its own replicate of the information
    - each data server must get the same information and respond in the same ways (Lamport's determinism)
    - have web server keep track of all possible data servers that can possibly be connected to (on different ports)
    - web server will send the *same* information to all active data servers
        - Lamport calls this an *atomic broadcast*

    - what if a data server goes down?
        - kill it forever and don't deal with setting it back up
        - other option (better but more difficult): connect back to it, but need to update it since downtime

    Q - web server needs to know which data servers are alive
        - either poll for data servers, or have data servers send a heartbeat message

    - server socket connections are done over TCP, so we're guaranteed in-order delivery to all data servers
    - if the data server is still alive, we're guaranteed that it will receive all of the messages
        - however, we're not guaranteed on timing

    Q - who to *retrieve* data from? just one server?

--------------------

Things to Keep Track Of:

- latency (should be relatively quick to access the data)
- consistency (all data servers should have the same data)
- network overhead (don't send too many messages)

- IMPOSE TOTAL ORDERING BY USING MESSAGE NUMBERS
    - QUEUE UP QUERIES (STRINGS) OTHERWISE

--------------------

Book Solution:

1 - front end multicasts request with unique identifier to replica managers
    - must use totally ordered, reliable multicast
        - order and reliability guaranteed by TCP
        - what about multicast?
    - do not request again until it receives a response

2 - coordination - enforce total order

3 - execution - RM's all process query identically

4 - agreement - none needed!

5 - response - ALL RM's send response
    - FE takes first response it receives and discards the rest (uses identifier)
    - all *must* send response, with identifier

- has sequential consistency
- relies on reliable multicast to ensure total order and same queries received at all RMs
- front end's requests are served in FIFO order (since must wait for a response)

--------------------

From long ago:

- include some sort of timestamps for messages
- consider having a way to see who you're being followed by
